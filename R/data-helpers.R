#' Prepare data for Thurstonian IRT models
#' 
#' @param data An object of class \code{data.frame} 
#' containing data of all variables used in the model.
#' @param blocks Object of class \code{TIRTblocks}
#' generated by \code{\link{set_block}} indicating
#' which items belong to which block, trait and more.
#' Ignored if data already contains information on 
#' the blocks.
#' 
#' @return A \code{data.frame} in a specific format
#' and with attributes ready for use with other
#' functions of the \pkg{ThurstonianIRT} package.
#' 
#' @export
make_TIRT_data <- function(data, blocks) {
  if (is.TIRTdata(data)) {
    return(data)
  }
  stopifnot(is.TIRTblocks(blocks))
  blocks <- blocks$blocks
  data <- as.data.frame(data)
  npersons <- nrow(data)
  nblocks <- length(blocks)
  nitems_per_block <- length(blocks[[1]]$items)
  ncomparisons <- (nitems_per_block * (nitems_per_block - 1)) / 2
  items_all <- ulapply(blocks, "[[", "items")
  nitems <- length(items_all)
  if (nitems != nitems_per_block * nblocks) {
    stop("All blocks should contain the same number of items.")
  }
  traits_all <- unique(ulapply(blocks, "[[", "traits"))
  ntraits <- length(traits_all)
  out <- tibble::tibble(
    person = rep(1:npersons, ncomparisons * nblocks),
    block = rep(1:nblocks, each = npersons * ncomparisons),
    comparison = rep(rep(1:ncomparisons, each = npersons), nblocks)
  )
  for (i in seq_len(nblocks)) {
    items <- blocks[[i]]$items
    item1 <- rep(
      items[1:(nitems_per_block - 1)], (nitems_per_block - 1):1
    )
    item2 <- unlist(lapply(
      2:nitems_per_block, function(x) items[x:nitems_per_block]
    ))
    traits <- blocks[[i]]$traits
    trait1 <- rep(
      traits[1:(nitems_per_block - 1)], (nitems_per_block - 1):1
    )
    trait2 <- unlist(lapply(
      2:nitems_per_block, function(x) traits[x:nitems_per_block]
    ))
    fblock <- (i - 1) * nitems_per_block
    comparison <- out[out$block == i, ]$comparison
    out[out$block == i, "itemC"] <- comparison + fblock
    out[out$block == i, "trait1"] <- trait1[comparison]
    out[out$block == i, "trait2"] <- trait2[comparison]
    out[out$block == i, "item1"] <- item1[comparison]
    out[out$block == i, "item2"] <- item2[comparison]
    resp_item1 <- unname(do.call(c, data[, item1]))
    resp_item2 <- unname(do.call(c, data[, item2]))
    out[out$block == i, "response"] <- as.numeric(resp_item1 < resp_item2)
  }
  out$item1 <- factor(out$item1, levels = items_all)
  out$item2 <- factor(out$item2, levels = items_all)
  out$trait1 <- factor(out$trait1, levels = traits_all)
  out$trait2 <- factor(out$trait2, levels = traits_all)
  
  # check for items being used multiple times in the test
  item_names <- ulapply(blocks, "[[", "names")
  dupl_item_nums <- which(duplicated(item_names))
  dupl_item_names <- unique(item_names[dupl_item_nums])
  dupl_items <- named_list(dupl_item_names)
  for (i in seq_along(dupl_items)) {
    dupl_items[[i]] <- which(item_names == dupl_item_names[i])
  }
  # add attributes to the returned object
  structure(out, 
    npersons = npersons, ntraits = ntraits, nblocks = nblocks,
    nitems = nitems, nitems_per_block = nitems_per_block,
    signs = ulapply(blocks, "[[", "signs"), dupl_items = dupl_items,
    class = c("TIRTdata", class(out))
  )
}

#' Prepare data for Thurstonian IRT models fitted with 
#' lavaan or Mplus
#' 
#' @inheritParams make_TIRT_data
#' 
#' @return A list of data ready to be passed to \pkg{lavaan}
#' or \pkg{Mplus}.
#' 
#' @import dplyr
#' @importFrom magrittr '%>%'
#' @export
make_sem_data <- function(data, blocks = NULL) {
  if (!is.TIRTdata(data)) {
    data <- make_TIRT_data(data, blocks)
  }
  data <- convert_factors(data)
  att <- attributes(data)
  npersons <- att[["npersons"]]
  ntraits <- att[["ntraits"]] 
  nblocks <- att[["nblocks"]]
  ncols <- ntraits * (ntraits - 1) / 2 * nblocks
  data %>% 
    mutate(itemC = paste0("i", item1, "i", item2)) %>%
    mutate(itemC = factor(itemC, levels = unique(itemC))) %>%
    select(person, itemC, response) %>%
    tidyr::spread(key = itemC, value = response) %>%
    select(-person)
}

convert_factors <- function(data) {
  # data and code generating functions require
  # items and traits to be numeric
  stopifnot(is.TIRTdata(data))
  for (v in c("item1", "item2", "trait1", "trait2")) {
    data[[v]] <- as.integer(data[[v]])
  }
  data
}

#' Prepare blocks of items
#' 
#' Prepare blocks of items and incorporate information
#' about which item belongs to which trait
#' 
#' @param items Names of item comparisons to be combined 
#' into one block. Should correspond to variables in the data.
#' @param trait Names of the traits to which each item belongs
#' @param names Optional names of the items in the output.
#' Can be used to equate parameters of items across blocks,
#' if the same item was used in different blocks.
#' @param signs Expected signs of the item loadings (1 or -1).
#' 
#' @examples 
#' set_block(
#'   items = c("i1i2", "i1i3", "i2i3"),
#'   traits = c("A", "B", "C")
#' ) + 
#' set_block(
#'   items = c("i4i5", "i4i6", "i5i6"),
#'   traits = c("A", "B", "C")
#' )
#' 
#' @export
set_block <- function(items, traits, names = items, signs = 1) {
  stopifnot(length(items) == length(traits))
  items <- as.character(items)
  traits <- as.character(traits)
  names <- as.character(names)
  if (length(signs) == 1L) {
    signs <- rep(signs, length(items))
  }
  stopifnot(length(items) == length(signs))
  signs <- sign(signs)
  out <- list(blocks = list(nlist(items, traits, names, signs)))
  structure(out, class = "TIRTblocks")
}

#' @rdname set_block
#' @export 
empty_block <- function() {
  structure(list(blocks = list()), class = "TIRTblocks")
}

#' @export
"+.TIRTblocks" <- function(e1, e2) {
  stopifnot(is.TIRTblocks(e2))
  e1$blocks <- c(e1$blocks, e2$blocks)
  e1
}

is.TIRTdata <- function(x) {
  inherits(x, "TIRTdata")
}

is.TIRTblocks <- function(x) {
  inherits(x, "TIRTblocks")
}
